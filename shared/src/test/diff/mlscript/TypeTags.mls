

class Foo[A]: { x: A; y: A }
//│ Defined class Foo[+A]

def foo: #Foo
//│ foo: Foo[?]
//│    = <missing implementation>

foo12 = Foo { x = 1; y = 2 }
//│ foo12: Foo[1 | 2] & {x: 1, y: 2}
//│      = Foo { x: 1, y: 2 }

foo = foo12
//│ Foo[1 | 2] & {x: 1, y: 2}
//│   <:  foo:
//│ Foo[?]
//│    = Foo { x: 1, y: 2 }

def test1 f = case f of { Foo -> f }
//│ test1: (Foo[?] & 'a) -> 'a
//│      = [Function: test1]

test1 foo
//│ res: Foo[?]
//│    = Foo { x: 1, y: 2 }

def test2 f = case f of { Foo -> f.x }
//│ test2: (Foo[?] & {x: 'x}) -> 'x
//│      = [Function: test2]

test2 foo12
//│ res: 1
//│    = 1


// * Only has the tag in its type, not the field
:e
test2 foo
//│ ╔══[ERROR] Type mismatch in application:
//│ ║  l.39: 	test2 foo
//│ ║        	^^^^^^^^^
//│ ╟── type `Foo[?]` does not have field 'x'
//│ ║  l.6: 	def foo: #Foo
//│ ║       	         ^^^^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.39: 	test2 foo
//│ ║        	      ^^^
//│ ╟── Note: constraint arises from field selection:
//│ ║  l.28: 	def test2 f = case f of { Foo -> f.x }
//│ ║        	                                 ^^^
//│ ╟── from reference:
//│ ║  l.28: 	def test2 f = case f of { Foo -> f.x }
//│ ╙──      	                   ^
//│ res: error
//│    = 1

// * Mistakenly passing the constructor
:e
foo = Foo
//│ {x: 'x & 'A, y: 'A & 'y} -> (Foo['A] & {x: 'x, y: 'y})
//│   <:  foo:
//│ Foo[?]
//│ ╔══[ERROR] Type mismatch in def definition:
//│ ║  l.60: 	foo = Foo
//│ ║        	^^^^^^^^^
//│ ╟── reference of type `{x: ?x, y: ?y} -> (Foo[?A] & {Foo#A = ?A, x: ?x, y: ?y})` is not an instance of type `Foo`
//│ ║  l.60: 	foo = Foo
//│ ║        	      ^^^
//│ ╟── Note: constraint arises from class tag:
//│ ║  l.6: 	def foo: #Foo
//│ ║       	         ^^^^
//│ ╟── Note: class constructor Foo is defined at:
//│ ║  l.3: 	class Foo[A]: { x: A; y: A }
//│ ╙──     	      ^^^
//│    = [Function: foo1]



:NoJS


def test: Foo[int] & ~#Foo
//│ test: nothing
test: nothing
//│ res: nothing

def test: Foo[int] & ~Foo[int]
//│ test: nothing
test: nothing
//│ res: nothing

type Id[A] = A
def test: Foo[int] & ~Foo[Id[int]]
//│ Defined type alias Id[+A]
//│ test: Foo[int] & ~Foo[Id[int]]
test: nothing
//│ res: nothing

// * Note: this one would only reduce to nothing if `int <: string`
def test: Foo[int] & ~Foo[string]
//│ test: Foo[int] & ~Foo[string]
:e
test: nothing
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.104: 	test: nothing
//│ ║         	^^^^
//│ ╟── type `int` is not an instance of type `string`
//│ ║  l.101: 	def test: Foo[int] & ~Foo[string]
//│ ║         	              ^^^
//│ ╟── Note: constraint arises from type reference:
//│ ║  l.101: 	def test: Foo[int] & ~Foo[string]
//│ ╙──       	                          ^^^^^^
//│ res: nothing


class Bar[A]: Foo[(A, A)]
//│ Defined class Bar[+A]

def test: Bar[int] & ~#Foo
//│ test: nothing
test: nothing
//│ res: nothing

def test: Bar[int] & ~#Bar
//│ test: nothing
test: nothing
//│ res: nothing


