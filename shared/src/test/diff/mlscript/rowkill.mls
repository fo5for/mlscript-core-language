
:NoJS

r1 = {y = 2} : ({x: 1; y: 2} | ~{x: nothing}) & {{y}}
//│ r1: {{y}} & {x: 1, y: 2} | {{y}} & ~{x: nothing}

r1 : {y: 2}
//│ res: {y: 2}

r1.y
//│ res: 2

:e
r1.x
//│ ╔══[ERROR] Type mismatch in field selection:
//│ ║  l.14: 	r1.x
//│ ║        	^^^^
//│ ╟── type `{{y}} & {x: 1, y: 2} | {{y}} & ~{x: nothing}` does not have field 'x'
//│ ║  l.4: 	r1 = {y = 2} : ({x: 1; y: 2} | ~{x: nothing}) & {{y}}
//│ ║       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{x: ?x}`
//│ ║  l.14: 	r1.x
//│ ╙──      	^^
//│ res: 1 | error

:e
r1 : {{x; y}}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.27: 	r1 : {{x; y}}
//│ ║        	^^
//│ ╟── type `{{y}} & {x: 1, y: 2} | {{y}} & ~{x: nothing}` does not match type `{{x, y}}`
//│ ║  l.4: 	r1 = {y = 2} : ({x: 1; y: 2} | ~{x: nothing}) & {{y}}
//│ ║       	               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{{x, y}}`
//│ ║  l.27: 	r1 : {{x; y}}
//│ ║        	^^
//│ ╟── Note: constraint arises from record fields type:
//│ ║  l.27: 	r1 : {{x; y}}
//│ ╙──      	     ^^^^^^^^
//│ res: {{x, y}}

r2 = {x = false; y = 2} : ({x: 1; y: 2} | ~{x: nothing}) & {x: false}
//│ r2: {x: false} & ~{x: nothing} | {x: nothing, y: 2}

r2 : {x: false; y: 2}
//│ res: {x: false, y: 2}

r3 = {x = false; y = 2}
//│ r3: {{x, y}} & {x: false, y: 2}

r3 : {{x; y}}
//│ res: {{x, y}}

r3 : {{x; y; *}}
//│ res: {{x, y, *}}

r3 : {{x; *}}
//│ res: {{x, *}}

:e
r3 : {{x; y; z}}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.61: 	r3 : {{x; y; z}}
//│ ║        	^^
//│ ╟── reference of type `{{x, y}} & {x: false, y: 2}` does not match type `{{x, y, z}}`
//│ ╟── Note: constraint arises from record fields type:
//│ ║  l.61: 	r3 : {{x; y; z}}
//│ ╙──      	     ^^^^^^^^^^^
//│ res: {{x, y, z}}

:e
r3 : {{x; z}}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.72: 	r3 : {{x; z}}
//│ ║        	^^
//│ ╟── reference of type `{{x, y}} & {x: false, y: 2}` does not match type `{{x, z}}`
//│ ╟── Note: constraint arises from record fields type:
//│ ║  l.72: 	r3 : {{x; z}}
//│ ╙──      	     ^^^^^^^^
//│ res: {{x, z}}

:e
r3 : {{x; *; z}}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.83: 	r3 : {{x; *; z}}
//│ ║        	^^
//│ ╟── reference of type `{{x, y}} & {x: false, y: 2}` does not match type `{{x, z, *}}`
//│ ╟── Note: constraint arises from record fields type:
//│ ║  l.83: 	r3 : {{x; *; z}}
//│ ╙──      	     ^^^^^^^^^^^
//│ res: {{x, z, *}}

r3 : ({{x; y; *}} & {x: bool; y: int} | {{x; y; z; *}} & {x: bool; y: int; z: string}) & {{x; y}}
//│ res: {{x, y}} & {x: bool, y: int}

r3 : ({{x; y; *}} & {x: bool; y: int} | {{x; y; z; *}} & {x: bool; y: int; z: string}) & {{x; y; *}}
//│ res: {{x, y, *}} & {x: bool, y: int}

r3 : ({{x; y; *}} & {x: bool; y: int} | {{x; y; z; *}} & {x: bool; y: int; z: string}) & ~{{x; y; z; *}}
//│ res: {{x, y, *}} & {x: bool, y: int} & ~{{x, y, z, *}}

:e
r3 : ({{x; y; z; *}} | {{x; y; w; *}}) & ~{{x; y; w; *}}
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.103: 	r3 : ({{x; y; z; *}} | {{x; y; w; *}}) & ~{{x; y; w; *}}
//│ ║         	^^
//│ ╟── reference of type `{{x, y}} & {x: false, y: 2}` does not match type `{{w, x, y, *}} | {{x, y, z, *}}`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.103: 	r3 : ({{x; y; z; *}} | {{x; y; w; *}}) & ~{{x; y; w; *}}
//│ ║         	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from intersection type:
//│ ║  l.103: 	r3 : ({{x; y; z; *}} | {{x; y; w; *}}) & ~{{x; y; w; *}}
//│ ╙──       	     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ res: {{x, y, z, *}} & ~{{x, y, w, *}}

r4 = if true then {x = 42; y = 43} else {x = 42; y = 43; z = 44}
//│ r4: {{x, y}} & {x: 42, y: 43} | {{x, y, z}} & {x: 42, y: 43, z: 44}

case r4 of
  { {{x; y; z}} -> r4.x + r4.y + r4.z
  | {{x; y}} -> r4.x + r4.y
  }
//│ res: int

case r4 of
  { {{x; y; *}} -> r4.x + r4.y
  }
//│ res: int

:e
case r4 of
  { {{x; y}} -> r4.x + r4.y
  }
//│ ╔══[ERROR] Type mismatch in `case` expression:
//│ ║  l.131: 	case r4 of
//│ ║         	^^^^^^^^^^
//│ ║  l.132: 	  { {{x; y}} -> r4.x + r4.y
//│ ║         	^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ║  l.133: 	  }
//│ ║         	^^^
//│ ╟── argument of type `{{x, y, z}} & {x: 42, y: 43, z: 44}` does not match type `{{x, y}}`
//│ ║  l.116: 	r4 = if true then {x = 42; y = 43} else {x = 42; y = 43; z = 44}
//│ ║         	                                        ^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── but it flows into reference with expected type `{{x, y}}`
//│ ║  l.131: 	case r4 of
//│ ╙──       	     ^^
//│ res: error | int

type Either[A, B] = {{l; *}} & {l: A} & ~{{r; *}} | {{r; *}} & {r: B} & ~{{l; *}}
//│ Defined type alias Either[+A, +B]

o1 = {l = true} : Either[bool, int]
//│ o1: Either[bool, int]

:e
{l = true; r = 42} : Either[bool, int]
//│ ╔══[ERROR] Type mismatch in type ascription:
//│ ║  l.156: 	{l = true; r = 42} : Either[bool, int]
//│ ║         	^^^^^^^^^^^^^^^^^^
//│ ╟── expression of type `{{l, r}} & {l: true, r: 42}` does not match type `{{l, *}} & {l: bool} & ~{{r, *}} | {{r, *}} & {r: int} & ~{{l, *}}`
//│ ╟── Note: constraint arises from union type:
//│ ║  l.149: 	type Either[A, B] = {{l; *}} & {l: A} & ~{{r; *}} | {{r; *}} & {r: B} & ~{{l; *}}
//│ ║         	                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
//│ ╟── from applied type reference:
//│ ║  l.156: 	{l = true; r = 42} : Either[bool, int]
//│ ╙──       	                     ^^^^^^^^^^^^^^^^^
//│ res: Either[bool, int]

def f1 o = case o of
  { {{l; *}} -> if o.l then 1 else 0
  | {{r; *}} -> o.r
  }
//│ f1: ({{l, *}} & {l: bool} | {{r, *}} & {r: 'r} & ~{{l, *}}) -> (0 | 1 | 'r)

f1 : Either[bool, int] -> int
//│ res: Either[bool, int] -> int

f1 o1
//│ res: 0 | 1

o2 = {l = true; iftrue = 42; iffalse = 43}
//│ o2: {{iffalse, iftrue, l}} & {iffalse: 43, iftrue: 42, l: true}

case o2 of
  { {{l; *}} -> if o2.l then o2.iftrue else o2.iffalse
  | {{r; *}} -> 0
  }
//│ res: 0 | 42 | 43

// fun x -> fun y -> x ++ y
// //│ res: 'a -> ({$fields: 'a} & 'b) -> ('a & 'b)

// r3 = {x = 1; y = true} ++ {y = 2}
// //│ r3: {{y}} & {y: 2} & ~{y: nothing}

// r3 : {x: 1; y: 2}
// //│ res: {x: 1, y: 2}

// r4 = {y = "hello"} ++ r3
// //│ r4: {{y}} & {y: nothing} & ~{y: nothing}

// // FIXME
// // :e
// r3.z
// //│ res: nothing
